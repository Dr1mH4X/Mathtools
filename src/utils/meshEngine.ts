import type { ComputedRegion, RotationAxis, MeshProfilePoint } from "./types";

// ===================================================================
// Mesh Engine
//
// Handles 3D mesh generation for the revolution solid:
//   1. generateMeshProfiles       — 2D region → radial/axial profile points
//   2. generateRevolutionGeometry — profile → swept triangle mesh
//   3. computeNormals             — smooth vertex normals from triangle mesh
//
// Per-vertex coloring:
//   Each profile point is tagged with an `origin` field ("upper" | "lower")
//   so that the swept mesh can carry a per-vertex color buffer.  The caller
//   passes two hex colour strings (one per curve) and the engine writes an
//   RGB Float32Array that Three.js can consume as a `color` BufferAttribute
//   with `vertexColors: true`.
// ===================================================================

/**
 * Extended profile point that remembers which boundary curve it came from.
 *
 * `origin` is `null` for degenerate points whose radius has been forced to 0
 * (e.g. when the rotation axis lies between the two curves).  These points
 * don't contribute visible surface area, so their colour is irrelevant — the
 * rendering code falls back to the outer curve's colour for them.
 */
interface TaggedProfilePoint extends MeshProfilePoint {
  origin: "upper" | "lower" | null;
}

/**
 * Generate profile points for 3D mesh construction.
 *
 * For rotation around x-axis:
 *   - axisPos = x
 *   - radius = |y - axisValue|
 *   - For each x position, we need outer and inner radii
 *
 * For rotation around y-axis:
 *   - axisPos = y (height along the axis)
 *   - radius = |x - axisValue|
 *   - The solid is generated by shells at each radius
 *
 * Returns an array of outer and inner profiles for washer/shell construction,
 * each tagged with `origin` ("upper" or "lower") indicating which 2D curve
 * produced the point.
 */
export function generateMeshProfiles(
  region: ComputedRegion,
  axis: RotationAxis,
  axisValue: number = 0,
): { outer: TaggedProfilePoint[]; inner: TaggedProfilePoint[] } {
  const { upperProfile, lowerProfile } = region;
  const outer: TaggedProfilePoint[] = [];
  const inner: TaggedProfilePoint[] = [];

  if (axis === "x") {
    // Rotating around y = axisValue (horizontal axis)
    for (let i = 0; i < upperProfile.length; i++) {
      const up = upperProfile[i]!;
      const lo = lowerProfile[i]!;
      const x = up.x;
      const yUp = up.y;
      const yLo = lo.y;

      const d1 = Math.abs(yUp - axisValue);
      const d2 = Math.abs(yLo - axisValue);

      const axisInside =
        axisValue >= Math.min(yUp, yLo) && axisValue <= Math.max(yUp, yLo);

      // Determine which curve is farther from the axis (outer surface)
      const upperIsOuter = d1 >= d2;

      outer.push({
        axisPos: x,
        radius: Math.max(d1, d2),
        origin: upperIsOuter ? "upper" : "lower",
      });
      inner.push({
        axisPos: x,
        radius: axisInside ? 0 : Math.min(d1, d2),
        // When the axis sits between the curves the inner radius is forced
        // to 0 — the point is degenerate and produces no visible surface.
        // We mark its origin as null so the colour lookup can fall back to
        // the outer curve's colour instead of incorrectly painting a
        // zero-radius seam with the opposite curve's colour.
        origin: axisInside ? null : upperIsOuter ? "lower" : "upper",
      });
    }
  } else {
    // For y-axis rotation, all points at the same x have the same radius
    // The height varies based on the y-values
    for (let i = 0; i < upperProfile.length; i++) {
      const up = upperProfile[i]!;
      const lo = lowerProfile[i]!;
      const x = up.x;
      const yUp = up.y;
      const yLo = lo.y;

      // Radius is the distance from the rotation axis to this x position
      const radius = Math.abs(x - axisValue);

      // Outer profile uses the upper y-value as the height
      outer.push({ axisPos: yUp, radius, origin: "upper" });

      // Inner profile uses the lower y-value as the height
      // Both have the same radius since they're at the same x
      inner.push({ axisPos: yLo, radius, origin: "lower" });
    }
  }

  return { outer, inner };
}

// ---------------------------------------------------------------------------
// Hex colour helpers
// ---------------------------------------------------------------------------

/** Default fallback colour — matches the primary blue #4f6ef7 */
const FALLBACK_RGB: [number, number, number] = [0.31, 0.43, 0.97];

/**
 * Parse a CSS hex colour string (#RGB or #RRGGBB) into a linear-space
 * `[r, g, b]` tuple with values in 0–1.
 *
 * Invalid / unsupported input is handled gracefully: the function logs a
 * warning once and returns the default primary-blue fallback so the mesh
 * is always renderable.
 */
function hexToRGB(hex: string): [number, number, number] {
  if (typeof hex !== "string") {
    console.warn(`[meshEngine] hexToRGB: expected string, got ${typeof hex}`);
    return FALLBACK_RGB;
  }

  const h = hex.replace(/^#/, "");

  // Validate that the remaining characters are hex digits with valid length
  if (!/^[0-9a-fA-F]{3}$/.test(h) && !/^[0-9a-fA-F]{6}$/.test(h)) {
    console.warn(
      `[meshEngine] hexToRGB: unsupported hex format "${hex}", using fallback`,
    );
    return FALLBACK_RGB;
  }

  const n = parseInt(h, 16);
  if (h.length === 3) {
    const r = ((n >> 8) & 0xf) / 15;
    const g = ((n >> 4) & 0xf) / 15;
    const b = (n & 0xf) / 15;
    return [r, g, b];
  }
  return [((n >> 16) & 0xff) / 255, ((n >> 8) & 0xff) / 255, (n & 0xff) / 255];
}

/**
 * Generate vertices for a surface of revolution.
 * Takes a 2D profile (series of (radius, axisPos) points) and sweeps it
 * around the axis by `segments` angular steps.
 *
 * The returned `colors` Float32Array (3 floats per vertex, linear-space RGB)
 * is **always** present.  When `upperColor` / `lowerColor` are supplied they
 * are parsed via `hexToRGB`; when omitted (or invalid) the default primary
 * blue (`#4f6ef7`) is used as a fallback for the corresponding curve.
 * Profile points whose `origin` is `null` (degenerate zero-radius points
 * created when the axis lies between the curves) inherit the outer curve's
 * colour so that no visible seam is mis-coloured.
 *
 * Returns flat arrays suitable for Three.js BufferGeometry:
 *   positions: Float32Array (3 * vertexCount)
 *   indices:   Uint32Array  (3 * triangleCount)
 *   normals:   Float32Array (3 * vertexCount)
 *   colors:    Float32Array (3 * vertexCount)  — per-vertex RGB (always returned)
 */
export function generateRevolutionGeometry(
  region: ComputedRegion,
  axis: RotationAxis,
  axisValue: number = 0,
  angularSegments: number = 64,
  angleExtent: number = Math.PI * 2,
  upperColor?: string,
  lowerColor?: string,
): {
  positions: Float32Array;
  indices: Uint32Array;
  normals: Float32Array;
  colors: Float32Array;
} {
  const { outer, inner } = generateMeshProfiles(region, axis, axisValue);

  // Build a closed cross-section profile:
  // outer profile forward, then inner profile backward to close the loop
  const profile: TaggedProfilePoint[] = [];

  // Outer from start to end
  for (const p of outer) {
    profile.push(p);
  }

  // Cap at the end: connect outer end to inner end
  if (inner.length > 0) {
    // Inner from end to start (reversed)
    for (let i = inner.length - 1; i >= 0; i--) {
      profile.push(inner[i]!);
    }
  }

  const profileLen = profile.length;
  const angSegs = angularSegments;
  const vertCount = profileLen * (angSegs + 1);
  const triCount = profileLen * angSegs * 2;

  const positions = new Float32Array(vertCount * 3);
  const normals = new Float32Array(vertCount * 3);
  const colors = new Float32Array(vertCount * 3);
  const indices = new Uint32Array(triCount * 3);

  // Resolve per-profile-point RGB values
  const upperRGB = upperColor ? hexToRGB(upperColor) : FALLBACK_RGB;
  const lowerRGB = lowerColor ? hexToRGB(lowerColor) : FALLBACK_RGB;

  // Pre-compute per-profile-point colour so the inner loop stays tight.
  // Points with origin === null (degenerate, zero-radius) inherit the
  // outer curve's colour — they produce no visible surface, but having a
  // sensible colour avoids any interpolation artefacts at the seam.
  const profileRGB: [number, number, number][] = new Array(profileLen);
  for (let i = 0; i < profileLen; i++) {
    const origin = profile[i]!.origin;
    if (origin === "upper") {
      profileRGB[i] = upperRGB;
    } else if (origin === "lower") {
      profileRGB[i] = lowerRGB;
    } else {
      // null origin — degenerate point; fall back to outer (upper) colour
      profileRGB[i] = upperRGB;
    }
  }

  // Generate vertices by sweeping profile
  for (let j = 0; j <= angSegs; j++) {
    const angle = (j / angSegs) * angleExtent;
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);

    for (let i = 0; i < profileLen; i++) {
      const idx = j * profileLen + i;
      const pt = profile[i]!;
      const r = pt.radius;
      const h = pt.axisPos;

      let px: number, py: number, pz: number;

      if (axis === "x") {
        // Rotation axis is along X (horizontal)
        px = h;
        py = axisValue + r * cosA;
        pz = r * sinA;
      } else {
        // Rotation axis is along Y (vertical)
        px = axisValue + r * cosA;
        py = h;
        pz = r * sinA;
      }

      const base = idx * 3;
      positions[base] = px;
      positions[base + 1] = py;
      positions[base + 2] = pz;

      // Per-vertex colour
      const rgb = profileRGB[i]!;
      colors[base] = rgb[0];
      colors[base + 1] = rgb[1];
      colors[base + 2] = rgb[2];
    }
  }

  // Generate indices
  let triIdx = 0;
  for (let j = 0; j < angSegs; j++) {
    for (let i = 0; i < profileLen; i++) {
      const nextI = (i + 1) % profileLen;
      const a = j * profileLen + i;
      const b = j * profileLen + nextI;
      const c = (j + 1) * profileLen + nextI;
      const d = (j + 1) * profileLen + i;

      indices[triIdx++] = a;
      indices[triIdx++] = b;
      indices[triIdx++] = c;

      indices[triIdx++] = a;
      indices[triIdx++] = c;
      indices[triIdx++] = d;
    }
  }

  // Compute normals
  computeNormals(positions, indices, normals);

  return { positions, indices, normals, colors };
}

/**
 * Compute smooth vertex normals for a triangle mesh by accumulating
 * face normals and normalizing per vertex.
 */
function computeNormals(
  positions: Float32Array,
  indices: Uint32Array,
  normals: Float32Array,
): void {
  // Zero out normals
  normals.fill(0);

  // Accumulate face normals
  for (let i = 0; i < indices.length; i += 3) {
    const ia = indices[i]!;
    const ib = indices[i + 1]!;
    const ic = indices[i + 2]!;

    const ax = positions[ia * 3]!,
      ay = positions[ia * 3 + 1]!,
      az = positions[ia * 3 + 2]!;
    const bx = positions[ib * 3]!,
      by = positions[ib * 3 + 1]!,
      bz = positions[ib * 3 + 2]!;
    const cx = positions[ic * 3]!,
      cy = positions[ic * 3 + 1]!,
      cz = positions[ic * 3 + 2]!;

    const e1x = bx - ax,
      e1y = by - ay,
      e1z = bz - az;
    const e2x = cx - ax,
      e2y = cy - ay,
      e2z = cz - az;

    const nx = e1y * e2z - e1z * e2y;
    const ny = e1z * e2x - e1x * e2z;
    const nz = e1x * e2y - e1y * e2x;

    for (const idx of [ia, ib, ic]) {
      normals[idx * 3] = (normals[idx * 3] ?? 0) + nx;
      normals[idx * 3 + 1] = (normals[idx * 3 + 1] ?? 0) + ny;
      normals[idx * 3 + 2] = (normals[idx * 3 + 2] ?? 0) + nz;
    }
  }

  // Normalize
  for (let i = 0; i < normals.length; i += 3) {
    const nx = normals[i]!;
    const ny = normals[i + 1]!;
    const nz = normals[i + 2]!;
    const len = Math.sqrt(nx * nx + ny * ny + nz * nz);
    if (len > 1e-8) {
      normals[i] = nx / len;
      normals[i + 1] = ny / len;
      normals[i + 2] = nz / len;
    }
  }
}
